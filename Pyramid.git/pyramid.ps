%!PS-Adobe-2.0

% Pyramidal Fractal in PostScript
%
% Draws a 3-D pyramid fractal, as seen in a popular text on Fractals
%
% Initial version from 1995
%   Curt.McDowell@andrew.cmu.edu
%   Carnegie-Mellon University
%
% Updated 2020
%   Curt McDowell <coder@fishlet.com>
%
% Coordinate systems
%
%    3D: x goes toward viewer, y goes right, z goes up
%    2D: x goes right, y goes up
%
% User-Adjustable Parameters:
%
% Adjust rotation of pyramid by modifying Roll, Pitch and Yaw angles.
%
% The outermost pyramid is defined by four points, and is broken into
% sub-pyramids by connecting midpoints of the six edges.

/Roll 0 def   /Pitch 10 def   /Yaw 0 def
/ShadeLeft 0.95 def   /ShadeRight 0.5 def
/PageW 8.5 def   /PageH 11 def
/Side 0.65 def
/Order 5 def

/LightPos [1.0 1.0 1.0] def
/ViewPos  [2.0 0.0 0.0] def

% 3D dot product
/dot {				% q q ==> d
    				% [x1 y1 z1] [x2 y2 z2]
    1 index 0 get 		% [x1 y1 z1] [x2 y2 z2] x1
    1 index 0 get mul		% [x1 y1 z1] [x2 y2 z2] (x1*x2)
    2 index 1 get		% [x1 y1 z1] [x2 y2 z2] (x1*x2) y1
    2 index 1 get mul		% [x1 y1 z1] [x2 y2 z2] (x1*x2) (y1*y2)
    3 index 2 get		% [x1 y1 z1] [x2 y2 z2] (x1*x2) (y1*y2) z1
    3 index 2 get mul		% [x1 y1 z1] [x2 y2 z2] (x1*x2) (y1*y2) (z1*z2)
    add add			% [x1 y1 z1] [x2 y2 z2] d
    exch pop exch pop
} def

% 3D cross product
/cross {			% q q ==> q
    				% [x1 y1 z1] [x2 y2 z2]
    1 index 1 get 1 index 2 get mul 2 index 2 get 2 index 1 get mul sub
    2 index 2 get 2 index 0 get mul 3 index 0 get 3 index 2 get mul sub
    3 index 0 get 3 index 1 get mul 4 index 1 get 4 index 0 get mul sub
    				% [x1 y1 z1] [x2 y2 z2] px py pz
    3 array astore
    exch pop exch pop		% [(y1*z2 - z1*y2) (z1*x2 - x1*z2) (x1*y2 - y1*x2)]
} def

% 3D dot product

% Rotate a 3D point around 3 axes with Roll (x), Pitch (y), then Yaw (z).
%
% From Wikipedia "Rotation matrix":
%
%   R = Rz(Yaw) Ry(Pitch) Rx(Roll)
%
%       [ c(Y)  -s(Y)  0 ] [  c(P)  0  s(P) ] [ 1  0      0    ]
%     = | s(Y)   c(Y)  0 | |  0     1  0    | | 1  c(R)  -s(R) |
%       [ 0      0     1 ] [ -s(P)  0  c(P) ] [ 0  s(R)   c(R) ]
%
%       [ x c(Y) c(P) + y (c(Y) s(P) s(R) - s(Y) c(R)) + z (c(Y) s(P) c(R) + s(Y) s(R)) ]
%  qR = | x s(Y) c(P) + y (s(Y) s(P) s(R) + c(Y) c(R)) + z (s(Y) s(P) c(R) - c(Y) s(R)) |
%       [ x (-s(P))   + y c(P) s(R)                    + z c(P) c(R)                    ]

/xrotate {	% q ==> q
    9 dict begin   aload pop   /z exch def   /y exch def   /x exch def

    /cosR Roll  cos def   /sinR Roll  sin def
    /cosP Pitch cos def   /sinP Pitch sin def
    /cosY Yaw   cos def   /sinY Yaw   sin def

    [
	x cosY mul cosP mul
	y cosY sinP mul sinR mul sinY cosR mul sub mul add
	z cosY sinP mul cosR mul sinY sinR mul add mul add

	x sinY mul cosP mul
	y sinY sinP mul sinR mul cosY cosR mul add mul add
	z sinY sinP mul cosR mul cosY sinR mul sub mul add

	x sinP neg mul
	y cosP mul sinR mul add
	z cosP mul cosR mul add
    ]
    end
} def

% Map a 3D point q to a 2D point p
/xview {	% q ==> p
    3 dict begin   aload pop   /z exch def   /y exch def   /x exch def
    [
	% screen x
	y
	PageW 2 div mul
	PageW 2 div add

	% screen y (assumes PageW is less than or equal to pageH)
	z
	PageW 2 div mul
	PageH 2 div add
    ]
    end
} def

% Take the midpoint of a line between two 3D points
/qmid {		% q1 q2 ==> (q1 + q2) / 2
    2 dict begin   /q2 exch def   /q1 exch def
    [
        q1 0 get   q2 0 get   add   2 div
        q1 1 get   q2 1 get   add   2 div
        q1 2 get   q2 2 get   add   2 div
    ]
    end
} def

/pmoveto {	% p ==> --
    aload pop moveto
} def

/plineto {	% p ==> --
    aload pop lineto
} def

% Print stack contents bottom to top (for debugging)
/p {
    count 1 sub -1 0 { index == } for
} def

%%%%% Buffer datatype %%%%%

% A buffer is a expandable array
%
% The buffer is stored as an array of two elements, the first being the
% number of items in the buffer and the second being an array containing
% the items, where the array may be large than the number of items.
% This allows adding one item at a time with a reasonably small amount of copying.
%
% Example if a buffer has sufficient capacity for a new item
%   [3 [a b c x]] e ==> [3 [a b c e]]
%
% When a buffer is full, it gets copied and its capacity is doubled
%   [4 [a b c d]] e ==> [5 [a b c d e x x x]]

% Create an empty buffer
/buf_new {			% buf_new ==> buffer
    [ 0 [ null ] ]
} def

% Add an item to the end of the buffer, expanding it if necessary.

/buf_add {			% buffer item buf_add ==>
    				% [3 [a b c x]] e
    1 index aload pop length	% [3 [a b c x]] e 3 4	% occupancy=3, capacity=4
    eq				% [3 [a b c x]] e bool
    {
	% If full, double the allocation
				% [4 [a b c d]] e
	1 index aload pop	% [4 [a b c d]] e 4 [a b c d]
	exch 2 mul array	% [4 [a b c d]] e [a b c d] [x x x x x x x x]
	dup 0			% [4 [a b c d]] e [a b c d] [x x x x x x x x] [x x x x x x x x] 0
	4 3 roll		% [4 [a b c d]] e [x x x x x x x x] [x x x x x x x x] 0 [a b c d]
	putinterval		% [4 [a b c d]] e [a b c d x x x x]

	2 index 1		% [4 [a b c d]] e [a b c d x x x x] [4 [a b c d]] 1
	3 2 roll		% [4 [a b c d]] e [4 [a b c d]] 1 [a b c d x x x x]
	put			% [4 [a b c d x x x x]] e
    } if

    % Write item at insert position
    1 index 0 get		% [3 [a b c x]] e 3
    dup 1 add exch		% [3 [a b c x]] e 4 3
    3 index 1 get		% [3 [a b c x]] e 4 3 [a b c x]
    exch			% [3 [a b c x]] e 4 [a b c x] 3
    4 3 roll			% [3 [a b c x]] 4 [a b c x] 3 e
    put				% [3 [a b c e]] 4
    0 exch			% [3 [a b c e]] 0 4
    put				% --
} def

% Convert a buffer to array (no copying required)
/buf_toarray {			% buffer => array
    				% [3 [a b c x]]
    aload pop			% 3 [a b c x]
    0				% 3 [a b c x] 0
    3 2 roll			% [a b c x] 0 3
    getinterval			% [a b c]
} def

%%%%

% Print stack contents bottom to top (for debugging)
/p
{
    [ count 1 roll ] dup { == } forall aload pop
} def

% Generate the faces of a pyramid
% Each face is an array of three 3D points [q1 q2 q3]

/pyramid {	% q1 q2 q3 q4 order ==> --
    12 dict begin

    /order exch def

    /q4 exch def
    /q3 exch def
    /q2 exch def
    /q1 exch def

    order 1 gt {
	% For order > 1, generate pyramid of order - 1

	/q12 q1 q2 qmid def
	/q13 q1 q3 qmid def
	/q14 q1 q4 qmid def
	/q23 q2 q3 qmid def
	/q24 q2 q4 qmid def
	/q34 q3 q4 qmid def

	/order order 1 sub def

	q1  q12 q13 q14 order pyramid
	q12 q2  q23 q24 order pyramid
	q14 q24 q34 q4  order pyramid
	q13 q23 q3  q34 order pyramid
    } {
	% For order = 1, generate faces
	% As counter-clockwise polygons

	faces [q2 q1 q3] buf_add		% front left
	faces [q1 q4 q3] buf_add		% front right
	faces [q3 q4 q2] buf_add		% back
	faces [q1 q2 q4] buf_add		% bottom
    } ifelse
    end
} def

% Average three points of a face to find the center of it
/center {
    3 dict begin   aload pop   /p1 exch def   /p2 exch def   /p3 exch def
    [
	p1 0 get p2 0 get p3 0 get add add 3 div
	p1 1 get p2 1 get p3 1 get add add 3 div
	p1 2 get p2 2 get p3 2 get add add 3 div
    ]
    end
} def

% Bubble sort modified from Don Lancaster's
/bubblesort {		% array comparison => array
    3 dict begin
    /comparison exch def
    /arr exch def
    arr length 1 sub -1 1 {
	arr 0 get exch 1 exch 1 exch {
	    /posn exch def
	    arr posn get
	    2 copy comparison { exch } if
	    arr exch posn 1 sub exch put
	} for
	arr exch posn exch put
    } for
    arr
    end
} def

/rp Side def
/rn rp neg def

/render {
    /q1 [rp rp rp] xrotate def
    /q2 [rp rn rn] xrotate def
    /q3 [rn rn rp] xrotate def
    /q4 [rn rp rn] xrotate def

    /faces buf_new def
    q1 q2 q3 q4 Order pyramid
    /faces faces buf_toarray def

    % Sort faces by order of increasing x (back to front)
    faces { center 0 get exch center 0 get exch lt } bubblesort
    {
	/face exch def

	/q1 face 0 get def
	/q2 face 1 get def
	/q3 face 2 get def

	/p1 q1 xview def
	/p2 q2 xview def
	/p3 q3 xview def

	% Fill the face

	ShadeLeft setgray
	p1 pmoveto   p2 plineto   p3 plineto   closepath fill

	%ShadeLeft setgray
	%p2 pmoveto   p1 plineto   p3 plineto   closepath fill

	%ShadeRight setgray
	%p4 pmoveto   p1 plineto   p3 plineto   closepath fill

	% Outline the face

	0 setgray
	p1 pmoveto   p2 plineto   p3 plineto   closepath stroke
    } forall
} def

0 10 3600 {
    /Yaw exch def
%    /Pitch exch def
%    /Roll exch def

    72 72 scale
    0.5 72 div setlinewidth

    render
    showpage
} for
