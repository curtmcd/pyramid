%!
% Pyramidal Fractal in PostScript
%
% Draws a 3-D pyramid fractal, as seen in a popular text on Fractals
%
% Initial version from 1995
%   Curt.McDowell@andrew.cmu.edu
%   Carnegie-Mellon University
%
% Updated 2020
%   Curt McDowell <coder@fishlet.com>
%

72 72 scale
0.5 72 div setlinewidth

% Coordinate systems
%
%    3D: x goes toward viewer, y goes right, z goes up
%    2D: x goes right, y goes down
%
% User-Adjustable Parameters:
%
% Adjust rotation of pyramid by modifying Roll, Pitch and Yaw angles.
%
% The outermost pyramid is defined by four points, and is broken into
% sub-pyramids by connecting midpoints of the six edges.

/Roll 0 def   /Pitch 10 def   /Yaw 0 def
/ShadeLeft 0.95 def   /ShadeRight 0.5 def
/PageW 8.5 def   /PageH 11 def
/Side 0.65 def
/Order 5 def

0 -1 translate

% Rotate a 3D point around 3 axes with Roll (x), Pitch (y), then Yaw (z).
%
% From Wikipedia "Rotation matrix":
%
%   R = Rz(Yaw) Ry(Pitch) Rx(Roll)
%
%       [ c(Y)  -s(Y)  0 ] [  c(P)  0  s(P) ] [ 1  0      0    ]
%     = | s(Y)   c(Y)  0 | |  0     1  0    | | 1  c(R)  -s(R) |
%       [ 0      0     1 ] [ -s(P)  0  c(P) ] [ 0  s(R)   c(R) ]
%
%       [ x c(Y) c(P) + y (c(Y) s(P) s(R) - s(Y) c(R)) + z (c(Y) s(P) c(R) + s(Y) s(R)) ]
%  qR = | x s(Y) c(P) + y (s(Y) s(P) s(R) + c(Y) c(R)) + z (s(Y) s(P) c(R) - c(Y) s(R)) |
%       [ x (-s(P))   + y c(P) s(R)                    + z c(P) c(R)                    ]

% This matrix multiplication is expanded below.

/cosR Roll  cos def   /sinR Roll  sin def
/cosP Pitch cos def   /sinP Pitch sin def
/cosY Yaw   cos def   /sinY Yaw   sin def

/xrotate {	% q ==> q
    3 dict begin   aload pop   /z exch def   /y exch def   /x exch def
    [
	x cosY mul cosP mul
	y cosY sinP mul sinR mul sinY cosR mul sub mul add
	z cosY sinP mul cosR mul sinY sinR mul add mul add

	x sinY mul cosP mul
	y sinY sinP mul sinR mul cosY cosR mul add mul add
	z sinY sinP mul cosR mul cosY sinR mul sub mul add

	x sinP neg mul
	y cosP mul sinR mul add
	z cosP mul cosR mul add
    ]
    end
} def

% Map a 3D point q to a 2D point p
/xview {	% q ==> p
    3 dict begin   aload pop   /z exch def   /y exch def   /x exch def
    [
	% screen x
	y
	PageW 2 div mul
	PageW 2 div add

	% screen y (assumes PageW is less than or equal to pageH)
	z neg
	PageW 2 div mul
	PageH 2 div add
    ]
    end
} def

% Take the midpoint of a line between two 3D points
/qmid {		% q1 q2 ==> (q1 + q2) / 2
    2 dict begin   /q2 exch def   /q1 exch def
    [
        q1 0 get   q2 0 get   add   2 div
        q1 1 get   q2 1 get   add   2 div
        q1 2 get   q2 2 get   add   2 div
    ]
    end
} def

/pmoveto {	% p ==> --
    aload pop moveto
} def

/plineto {	% p ==> --
    aload pop lineto
} def

/pyramid {	% order q1 q2 q3 q4 order ==> --
    12 dict begin
    /q4 exch def   /q3 exch def   /q2 exch def   /q1 exch def  /order exch def
    order 1 gt { pyramid_sub } { pyramid_base } ifelse
    end
} def

/pyramid_sub {
    /q12 q1 q2 qmid def
    /q13 q1 q3 qmid def
    /q14 q1 q4 qmid def
    /q23 q2 q3 qmid def
    /q24 q2 q4 qmid def
    /q34 q3 q4 qmid def

    /order' order 1 sub def

    order' q1  q12 q13 q14 pyramid
    order' q12 q2  q23 q24 pyramid
    order' q14 q24 q34 q4  pyramid
    order' q13 q23 q3  q34 pyramid
} def

/pyramid_base {
    /p1 q1 xview def  % bottom front
    /p2 q2 xview def  % bottom left
    /p3 q3 xview def  % top
    /p4 q4 xview def  % bottom right

    % Fill the two visible faces with different shades

    ShadeLeft setgray
    p2 pmoveto   p1 plineto   p3 plineto   closepath fill

    ShadeRight setgray
    p4 pmoveto   p1 plineto   p3 plineto   closepath fill

    % Draw the five visible line segments

    0 setgray
    p2 pmoveto   p1 plineto   p4 plineto   p3 plineto
    closepath    p3 pmoveto   p1 plineto   stroke
} def

/rp Side def
/rn rp neg def

/q1 [rp rp rp] xrotate def
/q2 [rp rn rn] xrotate def
/q3 [rn rn rp] xrotate def
/q4 [rn rp rn] xrotate def

% The next step will be to calculate the order in which faces are
% drawn

% Pyramid faces (counter-clockwise)
/faces [
    [q1 q2 q4] def
    [q1 q3 q2] def
    [q1 q4 q3] def
    [q2 q3 q4] def
] def

% Average three points of a face to find the center of it
/center {
    3 dict begin   aload pop   /p1 exch def   /p2 exch def   /p3 exch def
    [
	p1 0 get p2 0 get p3 0 get add add 3 div
	p1 1 get p2 1 get p3 1 get add add 3 div
	p1 2 get p2 2 get p3 2 get add add 3 div
    ]
    end
} def

% Face center points
/centers [
    faces 0 get center
    faces 1 get center
    faces 2 get center
    faces 3 get center
] def

% Bubble sort modified from Don Lancaster's
/bubblesort {		% array comparison => array
    3 dict begin
    /comparison exch def
    /arr exch def
    arr length 1 sub -1 1 {
	arr 0 get exch 1 exch 1 exch {
	    /posn exch def
	    arr posn get
	    2 copy comparison { exch } if
	    arr exch posn 1 sub exch put
	} for
	arr exch posn exch put
    } for
    arr
    end
} def

% Sort faces by order of increasing x (back to front)

Order q1 q2 q3 q4 pyramid

showpage
