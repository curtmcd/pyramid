%!
% Pyramidal Fractal in PostScript
%
% Draws a 3-D pyramid fractal, as seen in a popular text on Fractals
%
% Initial version from 1995
%   Curt.McDowell@andrew.cmu.edu
%   Carnegie-Mellon University
%
% Updated 2020
%   Curt McDowell <coder@fishlet.com>
%

72 72 scale
0.5 72 div setlinewidth

% Coordinate systems
%
%    3D: x goes toward viewer, y goes right, z goes up
%    2D: x goes right, y goes up
%
% User-Adjustable Parameters:
%
% Adjust rotation of pyramid by modifying Roll, Pitch and Yaw angles.
%
% The outermost pyramid is defined by four points, and is broken into
% sub-pyramids by connecting midpoints of the six edges.

/Roll 0 def   /Pitch 10 def   /Yaw 0 def
/ShadeLeft 0.95 def   /ShadeRight 0.5 def
/PageW 8.5 def   /PageH 11 def
/Side 0.65 def
/Order 5 def

% Rotate a 3D point around 3 axes with Roll (x), Pitch (y), then Yaw (z).
%
% From Wikipedia "Rotation matrix":
%
%   R = Rz(Yaw) Ry(Pitch) Rx(Roll)
%
%       [ c(Y)  -s(Y)  0 ] [  c(P)  0  s(P) ] [ 1  0      0    ]
%     = | s(Y)   c(Y)  0 | |  0     1  0    | | 1  c(R)  -s(R) |
%       [ 0      0     1 ] [ -s(P)  0  c(P) ] [ 0  s(R)   c(R) ]
%
%       [ x c(Y) c(P) + y (c(Y) s(P) s(R) - s(Y) c(R)) + z (c(Y) s(P) c(R) + s(Y) s(R)) ]
%  qR = | x s(Y) c(P) + y (s(Y) s(P) s(R) + c(Y) c(R)) + z (s(Y) s(P) c(R) - c(Y) s(R)) |
%       [ x (-s(P))   + y c(P) s(R)                    + z c(P) c(R)                    ]

/cosR Roll  cos def   /sinR Roll  sin def
/cosP Pitch cos def   /sinP Pitch sin def
/cosY Yaw   cos def   /sinY Yaw   sin def

/xrotate {	% q ==> q
    3 dict begin   aload pop   /z exch def   /y exch def   /x exch def
    [
	x cosY mul cosP mul
	y cosY sinP mul sinR mul sinY cosR mul sub mul add
	z cosY sinP mul cosR mul sinY sinR mul add mul add

	x sinY mul cosP mul
	y sinY sinP mul sinR mul cosY cosR mul add mul add
	z sinY sinP mul cosR mul cosY sinR mul sub mul add

	x sinP neg mul
	y cosP mul sinR mul add
	z cosP mul cosR mul add
    ]
    end
} def

% Map a 3D point q to a 2D point p
/xview {	% q ==> p
    3 dict begin   aload pop   /z exch def   /y exch def   /x exch def
    [
	% screen x
	y
	PageW 2 div mul
	PageW 2 div add

	% screen y (assumes PageW is less than or equal to pageH)
	z
	PageW 2 div mul
	PageH 2 div add
    ]
    end
} def

% Take the midpoint of a line between two 3D points
/qmid {		% q1 q2 ==> (q1 + q2) / 2
    2 dict begin   /q2 exch def   /q1 exch def
    [
        q1 0 get   q2 0 get   add   2 div
        q1 1 get   q2 1 get   add   2 div
        q1 2 get   q2 2 get   add   2 div
    ]
    end
} def

/pmoveto {	% p ==> --
    aload pop moveto
} def

/plineto {	% p ==> --
    aload pop lineto
} def

% Print stack contents bottom to top (for debugging)
/p
{			% [ (a) (b) (c) ] [ (a) (b) (c) ]
    [ count 1 roll ] dup { == } forall aload pop
} def

% XXX
/array_concat
{
    exch 2 copy length exch length add array
    dup dup 5 2 roll copy length exch putinterval
} bind def

%%%%% Buffer datatype %%%%%

% Create an empty buffer
/buf_new {
    [ 0 null ]
} def

% Add an element to the end of the buffer, expanding it if necessary
/buf_add	% First element of array is the number of elements used
		% [3 a b c x x x] e ==> [3 a b c e x x]
		% Array length is doubled if full
		% [4 a b c d] e ==> [8 a b c d e x x x x]
{
    					% [3 a b c x] e
    exch				% e [3 a b c x]
    dup 0 get 1 add exch		% e 4 [3 a b c x]	% insert pos = 4
    dup 0 get exch			% e 4 3 [3 a b c x]	% current occupancy = 3
    dup length 1 sub			% e 4 3 [3 a b c x] 4	% capacity = 4
    3 2 roll				% e 4 [3 a b c x] 4 3
    eq					% e 4 [3 a b c x] bool	% true if full
    {
	% Double the allocation
					% e 5 [4 a b c d]
	dup 0 get 2 mul			% e 5 [4 a b c d] 8    % new capacity = 8
	1 add array			% e 5 [4 a b c d] [x x x x x x x x x]
	dup 3 2 roll 			% e 5 [x x x x x x x x x] [x x x x x x x x x] [4 a b c d]
	0 exch putinterval		% e 5 [4 a b c d x x x x]
    } if
    % Write to insert position
    					% e 4 [3 a b c x]
    dup					% e 4 [3 a b c x] [3 a b c x]
    4 1 roll				% [3 a b c x] e 4 [3 a b c x]
    3 1 roll				% [3 a b c x] [3 a b c x] e 4
    exch put				% [3 a b c e]
    % Increment occupancy
    dup 0 get 1 add			% [3 a b c e] 4
    exch dup 0				% 4 [3 a b c e] [3 a b c e] 0
    4 3 roll				% [3 a b c e] [3 a b c e] 0 4
    put					% [4 a b c e]
} def

% Iterate proc over buffer items, without copying buffer
/buf_forall	% [3 a b c x] {proc} =>
{
    exch				% {proc} [3 a b c x]
    dup 0 get				% {proc} [3 a b c x] 3
    1 exch 1 exch			% {proc} [3 a b c x] 1 1 3
    {
					% {proc} [3 a b c x] 1
	exch dup			% {proc} 1 [3 a b c x] [3 a b c x]
	3 2 roll			% {proc} [3 a b c x] [3 a b c x] 1
	get				% {proc} [3 a b c x] a
	2 index				% {proc} [3 a b c x] a {proc}
	exec				% {proc} [3 a b c x]
    } for
    pop pop
} def

/pyramid {	% q1 q2 q3 q4 order ==> --
    12 dict begin

    /order exch def

    /q4 exch def
    /q3 exch def
    /q2 exch def
    /q1 exch def

    order 1 gt {
	% For order > 1, generate pyramid of order - 1

	/q12 q1 q2 qmid def
	/q13 q1 q3 qmid def
	/q14 q1 q4 qmid def
	/q23 q2 q3 qmid def
	/q24 q2 q4 qmid def
	/q34 q3 q4 qmid def

	/order order 1 sub def

	q1  q12 q13 q14 order pyramid
	q12 q2  q23 q24 order pyramid
	q14 q24 q34 q4  order pyramid
	q13 q23 q3  q34 order pyramid
    } {
	% For order = 1, draw pyramid

	/p1 q1 xview def  % bottom front
	/p2 q2 xview def  % bottom left
	/p3 q3 xview def  % top
	/p4 q4 xview def  % bottom right

	% Fill the two visible faces with different shades

	ShadeLeft setgray
	p2 pmoveto   p1 plineto   p3 plineto   closepath fill

	ShadeRight setgray
	p4 pmoveto   p1 plineto   p3 plineto   closepath fill

	% Draw the five visible line segments

	0 setgray
	p2 pmoveto   p1 plineto   p4 plineto   p3 plineto
	closepath    p3 pmoveto   p1 plineto   stroke
    } ifelse
    end
} def

/rp Side def
/rn rp neg def

/q1 [rp rp rp] xrotate def
/q2 [rp rn rn] xrotate def
/q3 [rn rn rp] xrotate def
/q4 [rn rp rn] xrotate def

q1 q2 q3 q4 Order pyramid

% The next step will be to calculate the order in which faces are
% drawn

% Pyramid faces (counter-clockwise)
%/faces [
%    [q1 q2 q4] def
%    [q1 q3 q2] def
%    [q1 q4 q3] def
%    [q2 q3 q4] def
%] def
%
%% Average three points of a face to find the center of it
%/center {
%    3 dict begin   aload pop   /p1 exch def   /p2 exch def   /p3 exch def
%    [
%	p1 0 get p2 0 get p3 0 get add add 3 div
%	p1 1 get p2 1 get p3 1 get add add 3 div
%	p1 2 get p2 2 get p3 2 get add add 3 div
%    ]
%    end
%} def
%
%% Bubble sort modified from Don Lancaster's
%/bubblesort {		% array comparison => array
%    3 dict begin
%    /comparison exch def
%    /arr exch def
%    arr length 1 sub -1 1 {
%	arr 0 get exch 1 exch 1 exch {
%	    /posn exch def
%	    arr posn get
%	    2 copy comparison { exch } if
%	    arr exch posn 1 sub exch put
%	} for
%	arr exch posn exch put
%    } for
%    arr
%    end
%} def
%
%% Sort faces by order of increasing x (back to front)
%faces { center 0 get exch center 0 get exch lt } bubblesort
%
%Order faces pyramid

showpage
